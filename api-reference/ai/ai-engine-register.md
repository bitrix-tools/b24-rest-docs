# Зарегистрировать сервис ai.engine.register

{% note warning "Мы еще обновляем эту страницу" %}

Тут может не хватать некоторых данных — дополним в ближайшее время

{% endnote %}

{% if build == 'dev' %}

{% note alert "TO-DO _не выгружается на prod_" %}

- нужны правки под стандарт написания
- не указаны типы параметров
- не указана обязательность параметров
- отсутствуют примеры
- отсутствует ответ в случае успеха
- отсутствует ответ в случае ошибки
- не прописаны ссылки на несозданные ещё страницы.

{% endnote %}

{% endif %}

> Scope: [`ai_admin`](../scopes/permissions.md)
>
> Кто может выполнять метод: администратор

REST-метод для добавления пользовательского сервиса. Метод регистрирует **engine**, при повторном вызове обновляет его. Это не совсем место встройки, так как **endpoint** партнера должен следовать четким форматам.

#|
|| **Параметр** | **Описание** | **С версии** ||
|| **name**
[`unknown`](../data-types.md) | Осмысленное и короткое название, которое будет появляться в интерфейсе пользователя. | | ||
|| **code**
[`unknown`](../data-types.md) | Уникальный код engine | | ||
|| **category**
[`unknown`](../data-types.md) | Может быть либо text (генерация текста), либо image (генерация картинок), либо audio (распознавание текста). | | ||
|| **completions_url**
[`unknown`](../data-types.md) | endpoint для обработки пользовательского запроса. | | ||
|| **settings**
[`unknown`](../data-types.md) | Тип AI (см. описание ниже). Необязательный. | 23.800 | ||
|#

Метод в случае успеха вернёт ID добавленного **engine**.

## Тип AI

Массив параметров:

#|
|| **Параметр** | **Описание** | **С версии** ||
|| **code_alias**
[`unknown`](../data-types.md) | Тип AI. Доступны значения: ChatGPT (Open AI), GigaChat (Сбер), YandexGPT (Яндекс) (по умолчанию ChatGPT). | | ||
|| **model_context_type**
[`unknown`](../data-types.md) | Тип подсчета контекста. Доступны значения: token - токены, symbol - символы. По умолчанию token. | | ||
|| **model_context_limit**
[`unknown`](../data-types.md) | Объем контекста (по умолчанию 16К). Перед отправкой вам запроса пользователя, проверяется лимит контекста согласно типу подсчета. | | ||
|#

## Примеры

{% list tabs %}

- JS


    ```js
    try
    {
    	const response = await $b24.callMethod(
    		'ai.engine.register',
    		{
    			name: 'Ivanov GPT',
    			code: 'ivanov_gpt',
    			category: 'text',
    			completions_url: 'https://antonds.ru/ai/aul/completions/',
    			settings: {
    				code_alias: 'ChatGPT',
    				model_context_type: 'token',
    				model_context_limit: 16*1024,
    			},
    		}
    	);
    	
    	const result = response.getData().result;
    	console.info(result);
    }
    catch( error )
    {
    	console.error(error);
    }
    ```

- PHP


    ```php
    try {
        $response = $b24Service
            ->core
            ->call(
                'ai.engine.register',
                [
                    'name'            => 'Ivanov GPT',
                    'code'            => 'ivanov_gpt',
                    'category'        => 'text',
                    'completions_url' => 'https://antonds.ru/ai/aul/completions/',
                    'settings'        => [
                        'code_alias'          => 'ChatGPT',
                        'model_context_type'  => 'token',
                        'model_context_limit' => 16 * 1024,
                    ],
                ]
            );
    
        $result = $response
            ->getResponseData()
            ->getResult();
    
        echo 'Success: ' . print_r($result, true);
        // Нужная вам логика обработки данных
        processData($result);
    
    } catch (Throwable $e) {
        error_log($e->getMessage());
        echo 'Error registering AI engine: ' . $e->getMessage();
    }
    ```

- BX24.js

    ```javascript
    BX24.callMethod(
        'ai.engine.register',
        {
            name: 'Ivanov GPT',
            code: 'ivanov_gpt',
            category: 'text',
            completions_url: 'https://antonds.ru/ai/aul/completions/',
            settings: {
                code_alias: 'ChatGPT',
                model_context_type: 'token',
                model_context_limit: 16*1024,
            },
        },
        function(result)
        {
            if(result.error())
            {
                console.error(result.error());
            }
            else
            {
                console.info(result.data());
            }
        }
    );
    ```

{% endlist %}

## Endpoint

{% note info "Внимание!" %}

В скрипте все в едином потоке кода, это для примера. В режиме **production** необходимо вынести строчки кода в отдельную часть.

{% endnote %}


[Шаблон](https://helpdesk.bitrix24.ru/examples/endpoint.zip) для создания пользовательского endpoint можно использовать для кастомизации собственного сервиса.

## Важные моменты:

1. Скрипт должен принять запрос, отработать его быстро, принять и добавить в свою внутреннюю очередь.
2. Сервис с типом "image" должен отправлять асинхронные запросы.
3. Уметь возвращать различные статусы ответа (есть в примере):
  - 200 — обычный переход по ссылке;
  - 202 — если вы приняли запрос и добавили в очередь;
  - 503 — если сервис недоступен.

Ответ ожидается в течение определенного времени, потом колбек становится невалидным.

{% note info "Внимание!" %}

Помимо кода ответа, в случае успешной генерации, обработчик должен обязательно возвращать `json_encode(['result' => 'OK'])`.

{% endnote %}


Когда вы работаете с категорией провайдера **audio**, в ключе `prompt` вы получаете массив, который включает в себя следующие элементы:

- **file**: Ссылка на файл. Важно отметить, что файл может быть без расширения.
- **fields**: Вспомогательный внутренний массив, который содержит:
  - **type**: Content-type файла, что особенно важно, если файл без расширения (например, "audio/ogg").
  - **prompt**: Вспомогательный промпт для аудио-файла, который может содержать ключевую информацию для помощи в распознавании файла, например, название вашей компании.

В ответе провайдеру уходят так же дополнительные поля:

#|
|| **Поля** | **Описание** | **С версии** ||
|| **auth** | Данные по авторизации, | 23.600.0 ||
|| **payload_raw** | Сырое значение промпта (при использовании Copilot там будет символьный код использованного промпта) | 23.600.0 ||
|| **payload_provider** | Символьный код провайдера препромпта (при использовании Copilot там будет prompt). | 23.600.0 ||
|| **payload_prompt_text** | Если `payload_provider = prompt`, будет содержаться сырая инструкция препромпта. Это не обработанный препромпт для самостоятельного анализа. Подробнее в документации по [промптам](.). | 23.800.0 ||
|| **payload_markers** | Массив дополнительных маркеров от пользователя (`original_message`, `user_message`, `language`), использованный при формировании промпта. Подробнее в документации по [промптам](.). | 23.800.0 ||
|| **payload_role** | Роль (инструкция), использованная при формировании промпта. В GPT-подобных системах вы должны отправлять эту роль как системную в массиве сообщений. | 23.800.0 ||
|| **context** | Массив предшествующих сообщений в хронологическом порядке. Например, список комментариев к посту. Первым в таком списке контекста считается авторское сообщение (сам пост). Важно: Объем контекста, отправляемого вашему провайдеру, зависит от указанного вами объема провайдера и типа подсчета (подробнее в документации по провайдеру). По умолчанию метод подсчета "токены", объем 16K. Отправлять контекст непосредственной нейронке вы должны только если передан параметр collect_context, равный true (1). В остальных случаях он передается как доп.информация на ваше усмотрение. | 23.800.0 ||
|| **max_tokens** | Максимальное число лексем. Параметр контролирует длину вывода. Необязательный. | | ||
|| **temperature**^*^ | Температура. Параметр контролирует случайность вывода (низкие значения делают вывод более сфокусированным и детерминированным). Обязательный. | | ||
|#

\* - Обязательные параметры 

**Пример**

Допустим, к вам приходит (помимо прочей информации) три массива данных.

- prompt - содержит текущий запрос, это просто текст;
- payload_role - некий текст, содержащий инструкции;
- context - массив (допустим, тоже не пустой).

В этом случае, результирующий массив мы получаем как:

```json
[
    [
        "role": "system",
        "content": "$payload_role"
    ],
    [
        // весь массив context, или его часть, если вы хотите сэкономить запрос
        // но помните, что он идет в хронологическом порядке (снизу самые последние сообщения)
    ],
    [
        "role": "user",
        "content": "$prompt" // это текущий запрос, и он НЕ входит в контекст
    ]
]
```

{% include [Сноска о примерах](../../_includes/examples.md) %}
