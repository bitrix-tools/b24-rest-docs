# Входящая очередь событий

Концепция **"входящей очереди"** для обработки HTTP-запросов предполагает, что запросы на ваши обработчики событий вы не обрабатываете сразу по мере их поступления, а помещаете в очередь, откуда они поочередно извлекаются и обрабатываются вашим сервером или группой серверов. 

### Основной принцип:

1. **Запросы поступают на сервер**: Когда Битрикс24 отправляют на ваш обработчик события HTTP-запросы, они сначала поступают на сервер или балансировщик нагрузки. При этом в ответ на входящий запрос ваш сервер сразу отвечает, что запрос принят и обработан (HTTP 200/202). Таким образом, с точки зрения очереди событий Битрикс24 ваш обработчик работает максимально быстро, а значит в дальнейшем вызывается с максимальным приоритетом.
2. **Запросы добавляются в очередь**: Вместо немедленной обработки, данные из запроса вы должны сохранить в специальной очереди (например, в базе данных, кэш-системе или распределённой очереди).
3. **Извлечение запросов из очереди**: Независимо от поступающих запросов, один или несколько обработчиков (воркеров) извлекают запросы из очереди и обрабатывают их по одному или параллельно, в зависимости от доступных ресурсов.

### Преимущества:

1. **Управление нагрузкой**: Очереди позволяют обрабатывать запросы последовательно и не перегружать сервер при всплесках трафика.
2. **Повышение стабильности**: Даже если система испытывает высокую нагрузку, запросы не теряются, а ставятся в очередь и обрабатываются позже.
3. **Масштабируемость**: Очереди позволяют легко масштабировать систему, добавляя больше воркеров или серверов, которые обрабатывают запросы.
4. **Улучшение отклика для клиентов**: Клиентам можно сразу отправлять сообщение о том, что запрос принят, а не ждать завершения обработки.

### Простой вариант реализации:

#### 1. **Сохранение в базу данных (DB-based Queue)**

Самый простой способ — сохранить входящие запросы в базу данных.

- **Запросы поступают на сервер**, и информация о запросе (тело, метаданные) сохраняется в базу данных.
- **Фоновый процесс** или крон-задача регулярно проверяет базу данных на наличие новых запросов, обрабатывает их и обновляет статус.
  
Пример:

1. Битрикс24 отправляет запрос на ваш обработчик события, и запрос сохраняется в таблице `requests`.
2. Фоновая задача каждые несколько секунд проверяет таблицу и обрабатывает запросы.

**Преимущество**: Простота реализации.

**Недостатки**: Возможное снижение производительности при высоких нагрузках из-за конкуренции за доступ к базе данных.

Пример на PHP:

{% list tabs %}

- Обработчик события

    ```php
    // Сохраняем запрос в базу данных, больше ничего не делаем!
    $db->query("INSERT INTO requests (data, status) VALUES ('$data', 'pending')");
    ```

- Воркер

    ```php
    // Выбираем для обработки пакет записей из очереди
    $pendingRequests = $db->query("SELECT * FROM requests WHERE status='pending'");
    foreach ($pendingRequests as $request) {
        // Обрабатываем запрос
        processRequest($request);
        $db->query("UPDATE requests SET status='processed' WHERE id=".$request['id']);
    }
    ```

{% endlist %}

#### 2. **Использование Redis (или Memcached)**

Для повышения производительности можно использовать **Redis** или **Memcached** как простую очередь.

- Входящие запросы ставятся в очередь в Redis через команду `LPUSH` (добавить элемент в список).
- Обработчики (воркеры) извлекают запросы с помощью `RPOP` (взять элемент из конца списка) и обрабатывают их.

**Преимущества**: Быстрая работа, особенно при больших объёмах данных и высоких нагрузках.

Пример на PHP:

{% list tabs %}

- Обработчик события

    ```php
    // Сохраняем запрос в базу данных, больше ничего не делаем!
    $redis->lPush('request_queue', json_encode($requestData));
    ```

- Воркер

    ```php
    // Выбираем для обработки пакет записей из очереди
    while ($request = $redis->rPop('request_queue')) {
        processRequest(json_decode($request));
    }
    ```

{% endlist %}

#### 3. **RabbitMQ или Kafka (продвинутое решение)**

Для более сложных и крупных систем можно использовать системы очередей, такие как **RabbitMQ** или **Kafka**.

- **RabbitMQ**: Это популярная система очередей, которая поддерживает сложные сценарии маршрутизации сообщений, балансировки нагрузки и масштабирования. RabbitMQ поддерживает подтверждение сообщений, что гарантирует их доставку.
- **Kafka**: Используется в больших системах для работы с потоками данных. Kafka позволяет распределять данные между множеством потребителей, что повышает масштабируемость и надёжность.

**Преимущества**: Высокая масштабируемость, надёжность, возможность сложной маршрутизации и балансировки нагрузки.

Пример использования RabbitMQ на PHP:

{% list tabs %}

- Обработчик события

    ```php
    // Отправляет сообщение в очередь RabbitMQ, больше ничего не делаем!
    $connection = new AMQPStreamConnection('localhost', 5672, 'user', 'password');
    $channel = $connection->channel();
    $channel->queue_declare('request_queue', false, true, false, false);
    $channel->basic_publish(new AMQPMessage(json_encode($requestData)), '', 'request_queue');
    ```

- Воркер

    ```php
    // Обрабатываем сообщения из очереди
    $callback = function($msg) {
        processRequest(json_decode($msg->body));
    };
    $channel->basic_consume('request_queue', '', false, true, false, false, $callback);
    while($channel->is_consuming()) {
        $channel->wait();
    }
    ```

{% endlist %}

### Рекомендации по реализации входящей очереди

1. **Для небольших систем**: Можно начать с базы данных для сохранения запросов, что проще и легче реализовать.
2. **Для систем со средней нагрузкой**: Используйте Redis или Memcached, чтобы повысить производительность и обработку запросов в реальном времени.
3. **Для крупных и высоконагруженных систем**: Рассмотрите использование специализированных решений, таких как RabbitMQ или Kafka, чтобы обеспечить высокую доступность, масштабируемость и обработку больших объёмов данных.